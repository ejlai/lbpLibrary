#! /usr/bin/python
# -*- coding: utf-8 -*-

"""
lbpLibrary 3D wrapper
---------------------

"""

# import funkc√≠
import sys
import os.path
import numpy as np
import math
import ctypes
import scipy

def load() :
    """Function loads LBP library

			 RealtimeLbp.dll/libRealtimeLbp.so (win/lin)
    """
    lbplib = ctypes.cdll.LoadLibrary("${DYNLIB}")
    return lbplib	
	
def compute(lbplib, npIM, N, mask, radius):
		s = npIM.shape[0]
		r = npIM.shape[1]
		c = npIM.shape[2]    
		img = (ctypes.c_long * (r*c*s))()
		res = (ctypes.c_long * (int)(math.pow(2,N)))()
		maskPoints = (ctypes.c_long * (N * 8))()
		maskCoef = (ctypes.c_double * (N * 8))()  
		maskP = mask['mask'] 
		maskC = mask['maskCoef']

		for i in range(N*8):
			maskPoints[i] = (int)(maskP[i])
			maskCoef[i] = maskC[i]
		for i in range(s) :
			for j in range(r) :
				for k in range(c) :
					img[(r*c*i) + (c*j) + k] = npIM[i,j,k]
		lbplib.lbp3dCxx(r,c,s, ctypes.byref(maskPoints), ctypes.byref(maskCoef), N, (int)(mask['center']), radius, ctypes.byref(img), ctypes.byref(res))
		res2 = np.zeros((int)(math.pow(2,N)))
		for i in range((int)(math.pow(2,N))):
			res2[i] = res[i]
		return res2
		
def coordToPoints(coordx, coordy,coordz, width, height):
		points = np.zeros([len(coordx)*8,1], dtype = np.uint32)
		for i in range(len(coordx)):
			tempx = round(coordx[i])
			tempy = round(coordy[i])
			tempz = round(coordz[i])
		
			x = [tempx-0.5, tempx+0.5]
			y = [tempy-0.5, tempy+0.5]
			z = [tempz-0.5, tempz+0.5]
			if z[0] < 0:
				z[0] = 0.1
			if x[0] < 0:
				x[0] = 0.1
			if y[0] < 0:
				y[0] = 0.1			
			m = 0;
			for j in range(2):
				for k in range(2):
					for l in range(2):
						points[(i)*8 + m] = round(x[j]-0.5) + round(y[k]-0.5)*width + round(z[l]-0.5)*width*height; 					
						m = m + 1;
		return points		


	









